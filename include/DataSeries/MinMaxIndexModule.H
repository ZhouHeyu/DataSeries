/* -*-C++-*-
*******************************************************************************
*
* File:         MinMaxIndexModule.H
* RCS:          $Header: /mount/cello/cvs/DataSeries/include/DataSeries/MinMaxIndexModule.H,v 1.2 2005/02/15 01:18:34 anderse Exp $
* Description:  A module which uses the min/max index generated by 
                dsextentindex to pick out the appropriate extents
* Author:       Eric Anderson
* Created:      Tue Jun  1 15:30:49 2004
* Modified:     Thu Oct 28 23:46:31 2004 (Eric Anderson) anderse@hpl.hp.com
* Language:     C++
* Package:      N/A
* Status:       Experimental (Do Not Distribute)
*
* (C) Copyright 2004, Hewlett-Packard Laboratories, all rights reserved.
*
*******************************************************************************
*/

#ifndef __DATASERIES_MINMAXINDEXMODULE_H
#define __DATASERIES_MINMAXINDEXMODULE_H

#include <IndexSourceModule.H>
#include <GeneralField.H>

/** \brief Source module that uses a min/max index to pick the extents

 * dsextentindex generates an index file which has a min/max extent in
 * it that tells the minimum and the maximum for a bunch of fields for
 * each of a collection of extents in a bunch of files.  This module
 * will do a range overlap between two values and the min/max for two
 * different fields, and will then sort by either the min or the max
 * value associated with each of the extents.
 */

class MinMaxIndexModule : public IndexSourceModule {
public:
    /** selects extents where [minv..maxv] overlaps with
    [min_fieldname..max_fieldname] and returns the extents sorted by
    sort_fieldname with ties broken by filename and extent offset the
    module will automatically put the min: and max: on the min/max
    fieldnames, you need to put it on the sort one as neither choice
    makes generic sense */
    MinMaxIndexModule(const std::string &index_filename,
		      const std::string &index_type, 
		      const GeneralValue minv, 
		      const GeneralValue maxv,
		      const std::string &min_fieldname,
		      const std::string &max_fieldname,
		      const std::string &sort_fieldname);

    /** structure for defining an overlap range, caller defines
	minv, maxv, min_fieldname, max_fieldname */
    struct selector {
	// 2004-10-28, anderse: wanted to make the next 4 variables
	// const, but doing so means that the tmp.push_back(foo) in
	// the simple constructor throws some weird C++ error that I
	// can't understand enough to know how to fix it.
	GeneralValue minv, maxv;
	std::string min_fieldname, max_fieldname;

	GeneralField *minf, *maxf;
	selector(const GeneralValue &a, const GeneralValue &b,
		 const std::string &c, const std::string &d) 
	    : minv(a), maxv(b), 
	    min_fieldname(c), max_fieldname(d), 
	    minf(NULL), maxf(NULL) { }
    };

    /** selects extents where all selectors overlap (intersection)
	rules for the values as per the other constructor */
    MinMaxIndexModule(const std::string &index_filename,
		      const std::string &index_type,
		      std::vector<selector> intersection_list,
		      const std::string &sort_fieldname);

protected:
    virtual void lockedResetModule();

    virtual compressedPrefetch *lockedGetCompressedExtent();

private:
    void init(const std::string &index_filename,
	      std::vector<selector> &intersection_list,
	      const std::string &sort_fieldname);

    struct extentorder {
	int sourcenum;
	ExtentType::int64 offset;
	extentorder(int a, ExtentType::int64 b)
	    : sourcenum(a), offset(b) { }
    };
    std::vector<extentorder> extentList;
    const std::string index_type;
    unsigned curextent;
};

#endif
