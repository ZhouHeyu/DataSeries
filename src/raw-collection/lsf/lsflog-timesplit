#!/usr/bin/perl -w
BEGIN { @AnyDBM_File::ISA = qw(DB_File GDBM_File NDBM_File) }
use AnyDBM_File;  
use strict;
use FileHandle;
use File::Copy;
use File::Find;

die "Usage: $0 <basedir> <file{,.gz,.bz2}|dir>..."
    unless @ARGV >= 2 && -d $ARGV[0];

my $basedir = shift @ARGV;

my %processed;
if (! -f "$basedir/processed.db") {
    tie %processed, 'AnyDBM_File', "$basedir/processed-$$.db", O_CREAT|O_RDWR;
} else {
    copy("$basedir/processed.db","$basedir/processed-$$.db")
	or die "Copy failed: $!";
    tie %processed, 'AnyDBM_File', "$basedir/processed-$$.db", O_RDWR;
}
    
my @files;
find(sub { push(@files,$File::Find::name) if -f $_; },
     @ARGV);

$|=1;
my $basename;
if ($files[0] =~ /\blsb.acct\b/o) {
    foreach my $file (@files) {
	die "different types of files ($file) is not lsb.acct?!"
	    unless $file =~ /\blsb.acct\b/o;
    }
    $basename = 'lsb.acct';
} else {
    die "don't know how to interpret file type $files[0]";
}

foreach my $file (@files) {
    warn "relative path for $file"
	unless $file =~ m!^/!o;
    my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
	$atime,$mtime,$ctime,$blksize,$blocks)
	= stat($file);
    if (defined $processed{$file}) {
	if ($processed{$file} eq "$size-$mtime") {
	    print "skipping unchanged file $file\n";
	    next;
	}
	print "$file has been updated ($processed{$file} ne $size-$mtime)\n";
    }

    print "reading from $file:\n";
    my $fh = openfile($file);

    my @datagroup;
    my $startevfile = 'N/A';
    while(<$fh>) {
      	die "unknown input line $_"
	    unless /^"[A-Z_]+" "\d+\.\d+" (\d+) \d+/o;
	my $eventtime = $1;
	my $evfile = eventtime2file($eventtime);
	if ($evfile ne $startevfile) {
	    updateEventFile($startevfile,\@datagroup);
	    $startevfile = $evfile;
	    @datagroup = ();
	}
	push(@datagroup,$_);
    }
    updateEventFile($startevfile,\@datagroup);
    $processed{$file} = "$size-$mtime";
}

untie %processed or die "Unable to untie: $!";
unlink("$basedir/processed.db");
rename("$basedir/processed-$$.db","$basedir/processed.db")
    or die "Unable to rename: $!";

sub eventtime2file {
    my($eventtime) = @_;

    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) 
	= gmtime($eventtime);

    $year += 1900;
    $mon += 1;
    return sprintf("$year/%02d/${basename}.$year-%02d-%02d",
		   $mon,$mon,$mday);
}

sub updateEventFile {
    my($evfile,$newdata) = @_;

    if ($evfile eq 'N/A') {
	die "internal" unless @$newdata == 0;
	return;
    }
    die "internal" if @$newdata == 0;
    my $outname = "$basedir/$evfile";
    my $compresstype = '';
    $compresstype = '.gz' if -f "${outname}.gz";
    $compresstype = '.bz2' if -f "${outname}.bz2";

    if (! -f "$outname$compresstype") {
	print "  creating ${outname}.\n    ";
	mkdirpart($outname);
	open(OUTFILE,">$outname-new")
	    or die "Unable to open $outname-new for write: $!";
	print OUTFILE @$newdata;
	close(OUTFILE);
    } else {
	print "  updating ${outname}:\n    ";
	my $fh = openfile("$outname$compresstype");
	my @origdata = <$fh>;
	close($fh);
	open(OUTFILE,">$outname-new")
	    or die "Unable to open $outname-new for write: $!";
	my ($origidx,$newidx) = (0,0);
	my ($dup_count,$new_count,$orig_count) = (0,0,0);
	my %seen;
	while ($origidx < @origdata || $newidx < @$newdata) {
	    if ($origidx < @origdata && $newidx < @$newdata) {
		my $origline = $origdata[$origidx];
		my $newline = $newdata->[$newidx];
		if ($origline eq $newline) {
		    die "strange duplicate"
			if defined $seen{$origline};
		    $seen{$origline} = 1;
		    ++$dup_count;
		    print OUTFILE $origline;
		    ++$origidx;
		    ++$newidx;
		} else {
		    die "unknown orig line $_"
			unless $origline =~ /^"[A-Z_]+" "\d+\.\d+" (\d+) \d+/o;
		    my $origtime = $1;
		    die "unknown new line $_"
			unless $newline =~ /^"[A-Z_]+" "\d+\.\d+" (\d+) \d+/o;
		    my $newtime = $1;
		    if ($origtime <= $newtime) {
			die "strange duplicate"
			    if defined $seen{$origline};
			++$orig_count;
			print OUTFILE $origline;
			++$origidx;
		    } else {
			die "strange duplicate"
			    if defined $seen{$newline};
			++$new_count;
			print OUTFILE $newline;
			++$newidx;
		    }
		}
	    } elsif ($origidx < @origdata) {
		my $origline = $origdata[$origidx];
		die "strange duplicate"
		    if defined $seen{$origline};
		$seen{$origline} = 1;
		print OUTFILE $origline;
		++$origidx;
		++$orig_count;
	    } elsif ($newidx < @$newdata) {
		my $newline = $newdata->[$newidx];
		die "strange duplicate"
		    if defined $seen{$newline};
		$seen{$newline} = 1;
		print OUTFILE $newline;
		++$newidx;
		++$new_count;
	    } else {
		die "what";
	    }
	}
	my $totline = $dup_count + $new_count + $orig_count;
	print "$totline total: $dup_count dups, $orig_count original, $new_count new...";
    }
    $compresstype = '.gz' if $compresstype eq '';
    if ($compresstype eq '.gz') {
	print "compressing...";
	system("gzip -9 $outname-new") == 0
	    or die "gzip failed";
    } elsif ($compresstype eq '.bz2') {
	print "compressing...";
	system("bzip2 -9 $outname-new") == 0
	    or die "bzip2 failed";
    }
    if (-f "$outname$compresstype") {
	unlink("$outname$compresstype")
	    or die "unable to unlink: $!";
    }
    rename("$outname-new$compresstype","$outname$compresstype")
	or die "rename failed: $!";
    print "done.\n";
}

sub openfile {
    my ($filename) = @_;

    my $ret;
    if ($filename =~ /\.bz2$/o) {
	$ret = new FileHandle "bunzip2 -c < $filename |"
	    or die "bad: $!";
    } elsif ($filename =~ /\.gz$/o) {
	$ret = new FileHandle "gunzip -c < $filename |"
	    or die "bad: $!";
    } else {
	$ret = new FileHandle "$filename"
	    or die "bad: $!";
    }
    return $ret;
}

sub mkdirpart {
    my ($filename) = @_;
    
    my @filebits = split(m!/!o,$filename);
    my $dirname = shift @filebits;
    $dirname = '/' if $dirname eq '';
    while (@filebits > 0) {
	# because we mkdir before we add to the filename, we 
	# will not make the filename part of the directory.
	unless (-d $dirname) {
	    mkdir($dirname,0775) or die "can't mkdir $dirname: $!";
	}
	$dirname .= "/" . shift @filebits;
    }
}
