\section{File format specification}

\newcommand{\packFieldOrdering}{{\tt pack\_field\_ordering}\xspace}

This section provides a precise specification of the DataSeries
version 1 file format.  A conformant dataseries file must consist of
the following sections, as shown in figure~\ref{fig:dsorg}:

\begin{enumerate}
\item {\bf header}: The header includes the version number and check values.
\item {\bf extent-type extent}: The extent defining the types used in the file.
\item {\bf data extent}: Zero or more extents comprising data types defined in the extent-type extent.
\item {\bf index extent}: An extent indexing the types and locations of each exxtent.
\item {\bf trailer}: The trailer contains the offset of the index extent, and some additonal check values.
\end{enumerate}

A conformant implementation may parse files that are missing the index
or the trailer.  The extent-type extent and index extent are simply
data extents with pre-known types, and so will be described after we
specify the extent format.  A valid file must use the same byte
ordering for all values in a file.  A conformant implementation must
support both big endian and little endian orderings.

\subsection{types}

This specification defines the following types for use in defining the file format:

\begin{enumerate}
\item {\bf byte}: A one byte (8 bit), value ranging from 0..255.
\item {\bf int32}: A four byte (32 bit) signed two's complement value stored in host-byte order.
\item {\bf int64}: An eight byte (64 bit) signed two's complement value stored in host-byte order.
\item {\bf double}: An eight byte (64 bit) IEEE 754 floating point value stored in host-byte order.
\end{enumerate}

\subsection{header}

The DataSeries header is used to validate that a file is being
properly parsed. A conformant implementation should validate the
contents of the header, e.g. by calling isnan on the NaN check value.
The header must consist of the following values:

\begin{enumerate}
\item {\bf file-type}: Four bytes, 'DSv1' in ASCII, 0x44, 0x53, 0x76, 0x31 in hexadecimal
\item {\bf int32 check value}: In file byte order, 0x12345678
  (big endian = 0x12, 0x34, 0x56, 0x78; little endian = 0x78, 0x56, 0x34, 0x12).
\item {\bf int64 check value}: In file byte order, 0x123456789ABCDEF0
  (big endian 0x12 0x34 0x56 0x78 0x9a 0xbc 0xde 0xf0; little endian =
  0xf0 0xde 0xbc 0x9a 0x78 0x56 0x34 0x12).
\item {\bf double check value}: The double constant
  3.1415926535897932384 in file byte order.  (big endian 40 09 21 fb
  54 44 2d 18; little endian 18 2d 44 54 fb 21 09 40)
\item {\bf infinity check value}: The double IEEE +$\infty$ floating
  point constant  (big endian 7f f0 00 00 00 00 00 00; little endian
  00 00 00 00 00 00 f0 7f).
\item {\bf NaN check value}: Any double IEEE NaN floating point
  constant in file byte order.
\end{enumerate}

\subsection{trailer}

The DataSeries trailer is used to locate the index extent.  A
conformant implementation should validate the trailer, but may choose
to tolerate an invalid trailer.  The trailer consists of the following
bytes:

\begin{enumerate}
  \item {\bf constant bytes}: Four bytes, 0xFF, 0xFF, 0xFF, 0xFF.
  \item {\bf index extent size}: int32 in file byte order, byte size of
    the index extent in the file.
  \item {\bf inverse extent size}: int32 in file byte order, bitwise
    complement of the index extent size.
  \item {\bf semi-random bytes}: int32 in file byte order, an arbitrary
    32 bit integer.  The implementation should chose this value derived
    from the extents in a file so that file contents are reproducable.
  \item {\bf index extent offset}: int64 in file byte order, offset in
    bytes from the beginning of the file for the index extent.
  \item {\bf hash bytes}: int32 in file byte order, bob-jenkins lookup-2
    hash~\cite{bob-jenkins-hash-lookup-2} of the above bytes. 
\end{enumerate}

\subsection{extent}

An extent in a dataseries file stores the actual data of a dataseries
file, or the two special extents in the file.  When an extent is
written into a file, it is first packed, as specified by the pack\_*
attributes specified in the extent type.  The variable and fixed parts
of the extent are then separately compressed using some
general-purpose compressor.  An extent consists of the following
bytes:

\begin{enumerate}

  \item {\bf compressed fixed-data size}: int32 in file byte order,
    byte size of the compressed representation of the fixed data.

  \item {\bf compressed variable-data size}: int32 in file byte order,
    byte size of the compressed representation of the variable data.

  \item {\bf number of records}: int32 in file byte order, count of
    the number of records (rows) in this extent.

  \item {\bf uncompressed variable-data size}: int32 in file byte order, 
    byte size of the variable representation after it has been uncompressed.
    Since the variable data always starts with 4 0 bytes, those bytes are 
    included in the size of the variable compressed data, but are not included
    in the compressed representation.  An implementation must create the first
    4 zero bytes while reading an extent.

  \item {\bf compressed adler32 digest}: int32 in file byte order,
    adler32 digest of the compressed data.
    Section~\ref{sec:ff:checksums} describes how this field is calculated.

  \item {\bf partly-unpacked bob-jenkins hash}: int32 in file byte order,
    bob-jenkins hash of the data after it has been partly unpacked.
    TODO-eric: how calculated...

  \item {\bf fixed-records compression algorithm}: byte; index of the
    compression algorithm used for the fixed-data.  Valid compression algorithms
    are shown in section~\ref{sec:ff:compression-types}.

  \item {\bf variable-records compression algorithm}: byte; index of the
    compression algorithm used for the variable-data.  Valid compression algorithms
    are shown in section~\ref{sec:ff:compression-types}.

  \item {\bf extent type name length:} byte; length of the extent-type
    name.

  \item {\bf unused zero byte} byte; 0.  (pad to round up the header to multiple of 4 bytes)

  \item {\bf type name} {\it extent type name length} bytes.  Extent
    type name for the current extent.  Must be either one of the two
    pre-defined types, or one of the types defined in the extent-type
    extent.

  \item {\bf padding} 0--3 bytes; sufficient 0 bytes to pad the
    current offset to 4 byte alignment.  For example, if the type name
    is 7 bytes long, the padding would consist of 1 byte of 0.

  \item {\bf compressed fixed-data} {\it compressed fixed-data size}
    bytes.  The compressed bytes storing the fixed data.

  \item {\bf padding} 0--3 bytes; sufficient 0 bytes to pad the
    current offset to 4 byte alignment.  For example, if the
    compressed fixed-data size is 128, there would be no padding.

  \item {\bf compressed variable-data} {\it compressed variable-data size}
    bytes.  The compressed bytes storing the variable data.

  \item {\bf padding} 0--3 bytes; sufficient 0 bytes to pad the
    current offset to 4 byte alignment.  For example, if the
    compressed variable-data size is 9, the padding would consist of 3
    bytes of 0's.
\end{enumerate}

\subsection{Compression types}
\label{sec:ff:compression-types}

The following compression types are currently supported.  Each
compression type is identified with a single 1 byte identifier (0-255).

\begin{itemize}

\item {\bf none, id 0}: The extent is not compressed on data, the file
  representation is precicely the post-packing representation.  An
  implementation must support the none compression algorithm.

\item {\bf lzo, id 1}: The extent is compressed using the
  lzo~\cite{LZO} compression algorithm.  An implementation may support
  the lzo compression algorithm.

\item {\bf zlib, id 2}: The extent is compressed with the
  zlib~\cite{GZIP} compression algorithm (similar to gzip, but without
  some header bits).  An implementation should support the gzip
  compression algorithm.

\item {\bf bz2, id 3}: The extent is compressed with the
  bz2~\cite{BZIP2} compression algorithm.  An implementation should
  support the bz2 compression algorithm.

\item {\bf lzf, id 4}: The extent is compressed with the
  lzf~\cite{LZF} compression algorithm.  An implementation should
  support the lzf compression algorithm.

\end{itemize}

An implementation must verify the compression algorithm when reading
an extent and produce an error message if the compression algorithm is
not supported.  An implementation must not use any of the id's not
specified here.

\subsection{Type specifications}

DataSeries types for extents are specified in XML.  An implementation should
verify that the XML is valid.  The type specification for each type must
consist of exactly one XML element named {\it ExtentType}.  The ExtentType
element must have a {\it name} attribute.  The name attribute must be at most
255 characters in length.  The ExtentType element may contain a {\it namespace}
or {\it version} attribute.  If specified, the version attribute must be a pair
of digits separated by a period, i.e. it should match the regular expression
\texttt{\^[0-9]+\.[0-9]+\$}, and each of the numbers specified must be a
non-negative 32 bit integer.

Contained within the ExtentType element are a series of {\it field} elements.
An implementation should report an error if any other element types are
detected.  Each field element can have a variety of elements.  The ones defined
in this specification are {\it pack\_scale}, {\it pack\_relative}, {\it
  pack\_unique}, {\it opt\_doublebase}, and {\it opt\_nullable}.  An
implementation must report an error if any other attributes starting with
either {\it pack\_} or {\it opt\_} are present.  An implementation must not
report an error if attributes starting with other prefixes are present.

\subsection{Per-row field layout}

The per-row field layout determines how the data will be represented in memory.
There are two options that affect the in-memory representation: {\it
  pack\_pad\_record} and \packFieldOrdering we discuss both of these
as part of the algorithm the specifies offsets for all fields.  A conforming
implementation must position all fields at exactly the positions specified by
this algorithm.

TODO-eric: nullable fields add hidden booleans here.

The algorithm starts by performing a stable sort on the list of fields in one
of two orders.  If \packFieldOrdering is set to {\tt
  small\_to\_big\_sep\_var32}, or is not set, then the fields are sorted in the
order (boolean, byte, int32, variable32, int64/double), i.e. int64s and doubles
are considered identical for the purpose of the sort.  If \packFieldOrdering is
set to {\tt big\_to\_small\_sep\_var32}, then the fields are sorted in the
order (int64/double, int32, variable32, byte, boolean).

Next the fields a positioned contiguously in the order specified with padding
added to align each field to start aligned with its size, e.g. variable32
aligned to a 4 byte boundary.  The bit fields are ordered from bit 0 to bit 7
within each byte, so the first 8 boolean fields will be in the first bit, and the next 
Finally


\subsection{Packing and Unpacking}

Packing and unpacking are transforms performed on the data around the
generic compression.  The purpose is to improve the effectiveness of
the generic compression algorithm.  The allowed options are specified
in sections~\ref{sec:design:extent-options} and
sections~\ref{sec:design:field-options}.

TODO-eric: ...

\subsection{Checksums}
\label{sec:ff:checksums}

The dataseries file format is designed for high reliability with data
stored for extended periods of time.  Therefore, it includes two
checksums designed to verify that the data being read is valid.  An
implementation should validate the checksums when performing slow
operations.  An implementation may skip validating checksums on every
operations.

The adler32 checksum of the compressed data is calculated all but the
compressed checksum.  In particular, given an array of bytes that
represents the extent, it is calculated as follows:

\begin{enumerate}
\item {\bf initialize} csum = adler32(0, null, 0)
\item {\bf extent-header w/o csum} csum = adler32(csum, extent, 4*4)
\item {\bf remaining-extent data} csum = adler32(csum, extent + 5*4, extent\_size - 5*4)
\end{enumerate}


